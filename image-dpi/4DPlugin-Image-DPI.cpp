/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Image-DPI.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Image DPI
 #	author : miyako
 #	2020/06/20
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Image-DPI.h"

#pragma mark read

tsize_t tiff_Read(thandle_t h, tdata_t buf, tsize_t size) {
    
    tiff_src *tiff_input = (tiff_src *)h;
    
    tsize_t remaining = tiff_input->len - tiff_input->pos;
    tsize_t len = size > remaining ? remaining : size;
    if(len)
    {
        uint8_t *ptr = tiff_input->ptr + tiff_input->pos;
        memcpy(buf, ptr, len);
        tiff_input->pos += len;
    }

    return (tsize_t)len;
};

toff_t tiff_ReadSeek(thandle_t h, toff_t pos, int whence) {
    
    tiff_src *tiff_input = (tiff_src *)h;
    
    switch (whence)
    {
  case SEEK_SET:
            tiff_input->pos = pos;
            break;
  case SEEK_CUR:
            tiff_input->pos += pos;
            break;
  case SEEK_END:
            tiff_input->pos = tiff_input->len + (pos > 0 ? 0 : pos);
            break;
    }
    
    return tiff_input->pos;
};

toff_t tiff_ReadSize(thandle_t h) {
    
    tiff_src *tiff_input = (tiff_src *)h;
    
    return tiff_input->len;
};

#pragma mark write

tsize_t tiff_Write(thandle_t h, tdata_t bytes, tsize_t size) {
    
    tiff_dst *tiff_output = (tiff_dst *)h;
    
    std::vector<uint8_t> *buf = tiff_output->buf;
    
    tsize_t len = buf->size();

    tsize_t need = tiff_output->pos + size;
    
    if(need > len)
    {
        buf->resize(need);
    }
    
    uint8_t *ptr = (uint8_t *)&buf->at(tiff_output->pos);
    memcpy(ptr, bytes, size);
    
    return size;
};

toff_t tiff_WriteSeek(thandle_t h, toff_t pos, int whence) {
    
    tiff_dst *tiff_output = (tiff_dst *)h;
    
    switch (whence)
    {
  case SEEK_SET:
            tiff_output->pos = pos;
            break;
  case SEEK_CUR:
            tiff_output->pos += pos;
            break;
  case SEEK_END:
            tiff_output->pos = tiff_output->buf->size() + (pos > 0 ? 0 : pos);
            break;
    }
    
    return tiff_output->pos;
};

toff_t tiff_WriteSize(thandle_t h) {
//not used
    tiff_dst *tiff_output = (tiff_dst *)h;
    
    return tiff_output->buf->size();
};

tsize_t tiff_WriteRead(thandle_t h, tdata_t buf, tsize_t size) {
    
    tiff_dst *tiff_output = (tiff_dst *)h;
    
    tsize_t remaining = tiff_output->buf->size() - tiff_output->pos;
    tsize_t len = size > remaining ? remaining : size;
    
    if(len)
    {
        uint8_t *ptr = (uint8_t *)(&tiff_output->buf->at(tiff_output->pos));
        memcpy(buf, ptr, len);
        tiff_output->pos += len;
    }
    
    return (tsize_t)len;
};

#pragma mark common

int tiff_Close(thandle_t)
{
    return 0;
};

int tiff_Map(thandle_t, tdata_t*, toff_t*)
{
    return 0;
};

void tiff_Unmap(thandle_t, tdata_t, toff_t)
{
    return;
};

#pragma mark tiffcp

typedef int (*copyFunc)(TIFF* in, TIFF* out, uint32 l, uint32 w, uint16 samplesperpixel);
static    copyFunc pickCopyFunc(TIFF*, TIFF*, uint16, uint16);

#define    CopyField(tag, v) \
if (TIFFGetField(in, tag, &v)) TIFFSetField(out, tag, v)
#define    CopyField2(tag, v1, v2) \
if (TIFFGetField(in, tag, &v1, &v2)) TIFFSetField(out, tag, v1, v2)
#define    CopyField3(tag, v1, v2, v3) \
if (TIFFGetField(in, tag, &v1, &v2, &v3)) TIFFSetField(out, tag, v1, v2, v3)
#define    CopyField4(tag, v1, v2, v3, v4) \
if (TIFFGetField(in, tag, &v1, &v2, &v3, &v4)) TIFFSetField(out, tag, v1, v2, v3, v4)

#define    CopyTag(tag, count, type)    cpTag(in, out, tag, count, type)

#define    DECLAREcpFunc(x) \
static int x(TIFF* in, TIFF* out, \
uint32 imagelength, uint32 imagewidth, tsample_t spp)

#define    DECLAREreadFunc(x) \
static int x(TIFF* in, \
uint8* buf, uint32 imagelength, uint32 imagewidth, tsample_t spp)
typedef int (*readFunc)(TIFF*, uint8*, uint32, uint32, tsample_t);

#define    DECLAREwriteFunc(x) \
static int x(TIFF* out, \
uint8* buf, uint32 imagelength, uint32 imagewidth, tsample_t spp)
typedef int (*writeFunc)(TIFF*, uint8*, uint32, uint32, tsample_t);

DECLAREreadFunc(readContigStripsIntoBuffer) {
    
    tsize_t scanlinesize = TIFFScanlineSize(in);
    uint8* bufp = buf;
    uint32 row;
    int ignore = FALSE;
    
    (void) imagewidth; (void) spp;
    for (row = 0; row < imagelength; row++) {
        if (TIFFReadScanline(in, (tdata_t) bufp, row, 0) < 0
                && !ignore) {
            TIFFError(TIFFFileName(in),
                                "Error, can't read scanline %lu",
                                (unsigned long) row);
            return 0;
        }
        bufp += scanlinesize;
    }
    
    return 1;
}

void cpStripToTile(uint8* out, uint8* in,
                   uint32 rows, uint32 cols,
                   int outskew, int64 inskew) {
    
    while (rows-- > 0) {
        uint32 j = cols;
        while (j-- > 0)
            *out++ = *in++;
        out += outskew;
        in += inskew;
    }
}

DECLAREwriteFunc(writeBufferToContigTiles) {
    
    tmsize_t imagew = TIFFScanlineSize(out);
    uint32 tilew  = (uint32)TIFFTileRowSize(out);
    tmsize_t iskew = imagew - tilew;
    tsize_t tilesize = TIFFTileSize(out);
    tdata_t obuf;
    uint8* bufp = (uint8*) buf;
    uint32 tl, tw;
    uint32 row;
    
    //params
    uint32 tilelength = (uint32) -1;
    
    (void) spp;
    
    obuf = _TIFFmalloc(TIFFTileSize(out));
    if (obuf == NULL)
        return 0;
    _TIFFmemset(obuf, 0, tilesize);
    (void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
    (void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
    for (row = 0; row < imagelength; row += tilelength) {
        uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;
        uint32 colb = 0;
        uint32 col;
        
        for (col = 0; col < imagewidth && colb < imagew; col += tw) {
            /*
             * Tile is clipped horizontally.  Calculate
             * visible portion and skewing factors.
             */
            if (colb + tilew > imagew) {
                uint32 width = (uint32)(imagew - colb);
                int oskew = (int)(tilew - width);
                cpStripToTile((uint8*)obuf, bufp + colb,
                              nrow, width,
                                            oskew, oskew + iskew);
            } else
                cpStripToTile((uint8*)obuf, bufp + colb,
                              nrow, tilew,
                                            0, iskew);
            if (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {
                TIFFError(TIFFFileName(out),
                                    "Error, can't write tile at %lu %lu",
                                    (unsigned long) col,
                                    (unsigned long) row);
                _TIFFfree(obuf);
                return 0;
            }
            colb += tilew;
        }
        bufp += nrow * imagew;
    }
    _TIFFfree(obuf);
    return 1;
}

int cpImage(TIFF* in, TIFF* out, readFunc fin, writeFunc fout,
                uint32 imagelength, uint32 imagewidth, tsample_t spp) {
    
    int status = 0;
    tdata_t buf = NULL;
    tsize_t scanlinesize = TIFFRasterScanlineSize(in);
    tsize_t bytes = scanlinesize * (tsize_t)imagelength;
    /*
     * XXX: Check for integer overflow.
     */
    if (scanlinesize
            && imagelength
            && bytes / (tsize_t)imagelength == scanlinesize) {
        buf = _TIFFmalloc(bytes);
        if (buf) {
            if ((*fin)(in, (uint8*)buf, imagelength,
                                 imagewidth, spp)) {
                status = (*fout)(out, (uint8*)buf,
                                                 imagelength, imagewidth, spp);
            }
            _TIFFfree(buf);
        } else {
            TIFFError(TIFFFileName(in),
                                "Error, can't allocate space for image buffer");
        }
    } else {
        TIFFError(TIFFFileName(in), "Error, no space for image buffer");
    }
    
    return status;
}

DECLAREcpFunc(cpContigStrips2ContigTiles) {
    
    return cpImage(in, out,
                                 readContigStripsIntoBuffer,
                                 writeBufferToContigTiles,
                                 imagelength, imagewidth, spp);
}

void cpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type) {
    
    switch (type) {
        case TIFF_SHORT:
            if (count == 1) {
                uint16 shortv;
                CopyField(tag, shortv);
            } else if (count == 2) {
                uint16 shortv1, shortv2;
                CopyField2(tag, shortv1, shortv2);
            } else if (count == 4) {
                uint16 *tr, *tg, *tb, *ta;
                CopyField4(tag, tr, tg, tb, ta);
            } else if (count == (uint16) -1) {
                uint16 shortv1;
                uint16* shortav;
                CopyField2(tag, shortv1, shortav);
            }
            break;
        case TIFF_LONG:
        { uint32 longv;
            CopyField(tag, longv);
        }
            break;
        case TIFF_RATIONAL:
            if (count == 1) {
                float floatv;
                CopyField(tag, floatv);
            } else if (count == (uint16) -1) {
                float* floatav;
                CopyField(tag, floatav);
            }
            break;
        case TIFF_ASCII:
        { char* stringv;
            CopyField(tag, stringv);
        }
            break;
        case TIFF_DOUBLE:
            if (count == 1) {
                double doublev;
                CopyField(tag, doublev);
            } else if (count == (uint16) -1) {
                double* doubleav;
                CopyField(tag, doubleav);
            }
            break;
        default:
            TIFFError(TIFFFileName(in),
                                "Data type %d is not supported, tag %d skipped.",
                                tag, type);
    }
}

static struct cpTag {
    uint16 tag;
    uint16 count;
    TIFFDataType type;
} tags[] = {
    { TIFFTAG_SUBFILETYPE,        1, TIFF_LONG },
    { TIFFTAG_THRESHHOLDING,    1, TIFF_SHORT },
    { TIFFTAG_DOCUMENTNAME,        1, TIFF_ASCII },
    { TIFFTAG_IMAGEDESCRIPTION,    1, TIFF_ASCII },
    { TIFFTAG_MAKE,            1, TIFF_ASCII },
    { TIFFTAG_MODEL,        1, TIFF_ASCII },
    { TIFFTAG_MINSAMPLEVALUE,    1, TIFF_SHORT },
    { TIFFTAG_MAXSAMPLEVALUE,    1, TIFF_SHORT },
    { TIFFTAG_XRESOLUTION,        1, TIFF_RATIONAL },
    { TIFFTAG_YRESOLUTION,        1, TIFF_RATIONAL },
    { TIFFTAG_PAGENAME,        1, TIFF_ASCII },
    { TIFFTAG_XPOSITION,        1, TIFF_RATIONAL },
    { TIFFTAG_YPOSITION,        1, TIFF_RATIONAL },
    { TIFFTAG_RESOLUTIONUNIT,    1, TIFF_SHORT },
    { TIFFTAG_SOFTWARE,        1, TIFF_ASCII },
    { TIFFTAG_DATETIME,        1, TIFF_ASCII },
    { TIFFTAG_ARTIST,        1, TIFF_ASCII },
    { TIFFTAG_HOSTCOMPUTER,        1, TIFF_ASCII },
    { TIFFTAG_WHITEPOINT,        (uint16) -1, TIFF_RATIONAL },
    { TIFFTAG_PRIMARYCHROMATICITIES,(uint16) -1,TIFF_RATIONAL },
    { TIFFTAG_HALFTONEHINTS,    2, TIFF_SHORT },
    { TIFFTAG_INKSET,        1, TIFF_SHORT },
    { TIFFTAG_DOTRANGE,        2, TIFF_SHORT },
    { TIFFTAG_TARGETPRINTER,    1, TIFF_ASCII },
    { TIFFTAG_SAMPLEFORMAT,        1, TIFF_SHORT },
    { TIFFTAG_YCBCRCOEFFICIENTS,    (uint16) -1,TIFF_RATIONAL },
    { TIFFTAG_YCBCRSUBSAMPLING,    2, TIFF_SHORT },
    { TIFFTAG_YCBCRPOSITIONING,    1, TIFF_SHORT },
    { TIFFTAG_REFERENCEBLACKWHITE,    (uint16) -1,TIFF_RATIONAL },
    { TIFFTAG_EXTRASAMPLES,        (uint16) -1, TIFF_SHORT },
    { TIFFTAG_SMINSAMPLEVALUE,    1, TIFF_DOUBLE },
    { TIFFTAG_SMAXSAMPLEVALUE,    1, TIFF_DOUBLE },
    { TIFFTAG_STONITS,        1, TIFF_DOUBLE },
};
#define    NTAGS    (sizeof (tags) / sizeof (tags[0]))

void cpContigBufToSeparateBuf(uint8* out, uint8* in,
                                                 uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp,
                                                 int bytes_per_sample ) {
    
    while (rows-- > 0) {
        uint32 j = cols;
        while (j-- > 0)
        {
            int n = bytes_per_sample;
            
            while( n-- ) {
                *out++ = *in++;
            }
            in += (spp-1) * bytes_per_sample;
        }
        out += outskew;
        in += inskew;
    }
}

DECLAREwriteFunc(writeBufferToSeparateTiles) {
    
    uint32 imagew = (uint32)TIFFScanlineSize(out);
    tsize_t tilew  = TIFFTileRowSize(out);
    uint32 iimagew = (uint32)TIFFRasterScanlineSize(out);
    int iskew = (int)(iimagew - tilew*spp);
    tsize_t tilesize = TIFFTileSize(out);
    tdata_t obuf;
    uint8* bufp = (uint8*) buf;
    uint32 tl, tw;
    uint32 row;
    uint16 bps = 0, bytes_per_sample;
    
    obuf = _TIFFmalloc(TIFFTileSize(out));
    if (obuf == NULL)
        return 0;
    _TIFFmemset(obuf, 0, tilesize);
    (void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
    (void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
    (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
    if( bps == 0 )
    {
        TIFFError(TIFFFileName(out), "Error, cannot read BitsPerSample");
        _TIFFfree(obuf);
        return 0;
    }
    if( (bps % 8) != 0 )
    {
        TIFFError(TIFFFileName(out), "Error, cannot handle BitsPerSample that is not a multiple of 8");
        _TIFFfree(obuf);
        return 0;
    }
    bytes_per_sample = bps/8;
    
    for (row = 0; row < imagelength; row += tl) {
        uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;
        uint32 colb = 0;
        uint32 col;
        
        //params
        uint32 tilewidth = (uint32) -1;
        
        for (col = 0; col < imagewidth; col += tw) {
            tsample_t s;
            for (s = 0; s < spp; s++) {
                /*
                 * Tile is clipped horizontally.  Calculate
                 * visible portion and skewing factors.
                 */
                if (colb + tilew > imagew) {
                    uint32 width = (imagew - colb);
                    int oskew = (int)(tilew - width);
                    
                    cpContigBufToSeparateBuf((uint8*)obuf,
                                                                     bufp + (colb*spp) + s,
                                                                     nrow, width/bytes_per_sample,
                                                                     oskew, (oskew*spp)+iskew, spp,
                                                                     bytes_per_sample);
                } else
                    cpContigBufToSeparateBuf((uint8*)obuf,
                                                                     bufp + (colb*spp) + s,
                                                                     nrow, tilewidth,
                                                                     0, iskew, spp,
                                                                     bytes_per_sample);
                if (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {
                    TIFFError(TIFFFileName(out),
                                        "Error, can't write tile at %lu %lu "
                                        "sample %lu",
                                        (unsigned long) col,
                                        (unsigned long) row,
                                        (unsigned long) s);
                    _TIFFfree(obuf);
                    return 0;
                }
            }
            colb += tilew;
        }
        bufp += nrow * iimagew;
    }
    _TIFFfree(obuf);
    return 1;
}

DECLAREcpFunc(cpContigStrips2SeparateTiles) {
    
    return cpImage(in, out,
                                 readContigStripsIntoBuffer,
                                 writeBufferToSeparateTiles,
                                 imagelength, imagewidth, spp);
}

DECLAREreadFunc(readSeparateStripsIntoBuffer) {
    
    int status = 1;
    
    //params
    int ignore = FALSE;
    
    tsize_t scanlinesize = TIFFScanlineSize(in);
    tdata_t scanline;
    if (!scanlinesize)
        return 0;
    
    scanline = _TIFFmalloc(scanlinesize);
    if (!scanline)
        return 0;
    _TIFFmemset(scanline, 0, scanlinesize);
    (void) imagewidth;
    if (scanline) {
        uint8* bufp = (uint8*) buf;
        uint32 row;
        tsample_t s;
        for (row = 0; row < imagelength; row++) {
            /* merge channels */
            for (s = 0; s < spp; s++) {
                uint8* bp = bufp + s;
                tsize_t n = scanlinesize;
                uint8* sbuf = (uint8*)scanline;
                
                if (TIFFReadScanline(in, scanline, row, s) < 0
                        && !ignore) {
                    TIFFError(TIFFFileName(in),
                                        "Error, can't read scanline %lu",
                                        (unsigned long) row);
                    status = 0;
                    goto done;
                }
                while (n-- > 0)
                    *bp = *sbuf++, bp += spp;
            }
            bufp += scanlinesize * spp;
        }
    }
    
done:
    _TIFFfree(scanline);
    return status;
}

DECLAREcpFunc(cpSeparateStrips2ContigTiles) {
    
    return cpImage(in, out,
                                 readSeparateStripsIntoBuffer,
                                 writeBufferToContigTiles,
                                 imagelength, imagewidth, spp);
}

DECLAREcpFunc(cpSeparateStrips2SeparateTiles) {
    
    return cpImage(in, out,
                                 readSeparateStripsIntoBuffer,
                                 writeBufferToSeparateTiles,
                                 imagelength, imagewidth, spp);
}

DECLAREreadFunc(readContigTilesIntoBuffer) {
    
    int status = 1;
    tsize_t tilesize = TIFFTileSize(in);
    tdata_t tilebuf;
    uint32 imagew = TIFFScanlineSize(in);
    uint32 tilew  = TIFFTileRowSize(in);
    int64 iskew = (int64)imagew - (int64)tilew;
    uint8* bufp = (uint8*) buf;
    uint32 tw, tl;
    uint32 row;
    
    //params
    int ignore = FALSE;
    
    (void) spp;
    tilebuf = _TIFFmalloc(tilesize);
    if (tilebuf == 0)
        return 0;
    _TIFFmemset(tilebuf, 0, tilesize);
    (void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
    (void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);
    
    for (row = 0; row < imagelength; row += tl) {
        uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;
        uint32 colb = 0;
        uint32 col;
        
        for (col = 0; col < imagewidth && colb < imagew; col += tw) {
            if (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0
                    && !ignore) {
                TIFFError(TIFFFileName(in),
                                    "Error, can't read tile at %lu %lu",
                                    (unsigned long) col,
                                    (unsigned long) row);
                status = 0;
                goto done;
            }
            if (colb > iskew) {
                uint32 width = imagew - colb;
                uint32 oskew = tilew - width;
                cpStripToTile((uint8*)(bufp + colb),
                                            (uint8*)tilebuf, nrow, width,
                                            oskew + iskew, oskew );
            } else
                cpStripToTile((uint8*)(bufp + colb),
                                            (uint8*)tilebuf, nrow, tilew,
                                            iskew, 0);
            colb += tilew;
        }
        bufp += imagew * nrow;
    }
done:
    _TIFFfree(tilebuf);
    return status;
}

DECLAREcpFunc(cpContigTiles2ContigTiles) {
    
    return cpImage(in, out,
                                 readContigTilesIntoBuffer,
                                 writeBufferToContigTiles,
                                 imagelength, imagewidth, spp);
}

DECLAREcpFunc(cpContigTiles2SeparateTiles) {
    
    return cpImage(in, out,
                                 readContigTilesIntoBuffer,
                                 writeBufferToSeparateTiles,
                                 imagelength, imagewidth, spp);
}

void cpSeparateBufToContigBuf(uint8* out, uint8* in,
                                                 uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp,
                                                 int bytes_per_sample) {
    
    while (rows-- > 0) {
        uint32 j = cols;
        while (j-- > 0) {
            int n = bytes_per_sample;
            
            while( n-- ) {
                *out++ = *in++;
            }
            out += (spp-1)*bytes_per_sample;
        }
        out += outskew;
        in += inskew;
    }
}

DECLAREreadFunc(readSeparateTilesIntoBuffer)
{
    int status = 1;
    uint32 imagew = TIFFRasterScanlineSize(in);
    uint32 tilew = TIFFTileRowSize(in);
    int iskew  = imagew - tilew*spp;
    tsize_t tilesize = TIFFTileSize(in);
    tdata_t tilebuf;
    uint8* bufp = (uint8*) buf;
    uint32 tw, tl;
    uint32 row;
    uint16 bps = 0, bytes_per_sample;
    
    //params
    int ignore = FALSE;
    
    tilebuf = _TIFFmalloc(tilesize);
    if (tilebuf == 0)
        return 0;
    _TIFFmemset(tilebuf, 0, tilesize);
    (void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
    (void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);
    (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
    if( bps == 0 )
    {
        TIFFError(TIFFFileName(in), "Error, cannot read BitsPerSample");
        status = 0;
        goto done;
    }
    if( (bps % 8) != 0 )
    {
        TIFFError(TIFFFileName(in), "Error, cannot handle BitsPerSample that is not a multiple of 8");
        status = 0;
        goto done;
    }
    bytes_per_sample = bps/8;
    
    for (row = 0; row < imagelength; row += tl) {
        uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;
        uint32 colb = 0;
        uint32 col;
        
        for (col = 0; col < imagewidth; col += tw) {
            tsample_t s;
            
            for (s = 0; s < spp; s++) {
                if (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0
                        && !ignore) {
                    TIFFError(TIFFFileName(in),
                                        "Error, can't read tile at %lu %lu, "
                                        "sample %lu",
                                        (unsigned long) col,
                                        (unsigned long) row,
                                        (unsigned long) s);
                    status = 0;
                    goto done;
                }
                /*
                 * Tile is clipped horizontally.  Calculate
                 * visible portion and skewing factors.
                 */
                if (colb + tilew*spp > imagew) {
                    uint32 width = imagew - colb;
                    int oskew = tilew*spp - width;
                    cpSeparateBufToContigBuf(
                                                                     (uint8*)bufp+colb+s*bytes_per_sample,
                                                                     (uint8*)tilebuf, nrow,
                                                                     width/(spp*bytes_per_sample),
                                                                     oskew + iskew,
                                                                     oskew/spp, spp,
                                                                     bytes_per_sample);
                } else
                    cpSeparateBufToContigBuf(
                                                                     (uint8*)bufp+colb+s*bytes_per_sample,
                                                                     (uint8*)tilebuf, nrow, tw,
                                                                     iskew, 0, spp,
                                                                     bytes_per_sample);
            }
            colb += tilew*spp;
        }
        bufp += imagew * nrow;
    }
done:
    _TIFFfree(tilebuf);
    return status;
}

DECLAREcpFunc(cpSeparateTiles2ContigTiles)
{
    return cpImage(in, out,
                                 readSeparateTilesIntoBuffer,
                                 writeBufferToContigTiles,
                                 imagelength, imagewidth, spp);
}

DECLAREcpFunc(cpSeparateTiles2SeparateTiles)
{
    return cpImage(in, out,
                                 readSeparateTilesIntoBuffer,
                                 writeBufferToSeparateTiles,
                                 imagelength, imagewidth, spp);
}

DECLAREwriteFunc(writeBufferToContigStrips)
{
    uint32 row, rowsperstrip;
    tstrip_t strip = 0;
    
    (void) imagewidth; (void) spp;
    (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
    for (row = 0; row < imagelength; row += rowsperstrip) {
        uint32 nrows = (row+rowsperstrip > imagelength) ?
        imagelength-row : rowsperstrip;
        tsize_t stripsize = TIFFVStripSize(out, nrows);
        if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0) {
            TIFFError(TIFFFileName(out),
                                "Error, can't write strip %u", strip - 1);
            return 0;
        }
        buf += stripsize;
    }
    return 1;
}

DECLAREcpFunc(cpContigTiles2ContigStrips)
{
    return cpImage(in, out,
                                 readContigTilesIntoBuffer,
                                 writeBufferToContigStrips,
                                 imagelength, imagewidth, spp);
}

DECLAREwriteFunc(writeBufferToSeparateStrips)
{
    uint32 rowsize = imagewidth * spp;
    uint32 rowsperstrip;
    tsize_t stripsize = TIFFStripSize(out);
    tdata_t obuf;
    tstrip_t strip = 0;
    tsample_t s;
    
    obuf = _TIFFmalloc(stripsize);
    if (obuf == NULL)
        return (0);
    _TIFFmemset(obuf, 0, stripsize);
    (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
    for (s = 0; s < spp; s++) {
        uint32 row;
        for (row = 0; row < imagelength; row += rowsperstrip) {
            uint32 nrows = (row+rowsperstrip > imagelength) ?
            imagelength-row : rowsperstrip;
            tsize_t stripsize = TIFFVStripSize(out, nrows);
            
            cpContigBufToSeparateBuf(
                                                             (uint8*)obuf, (uint8*) buf + row*rowsize + s,
                                                             nrows, imagewidth, 0, 0, spp, 1);
            if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0) {
                TIFFError(TIFFFileName(out),
                                    "Error, can't write strip %u",
                                    strip - 1);
                _TIFFfree(obuf);
                return 0;
            }
        }
    }
    _TIFFfree(obuf);
    return 1;
    
}

DECLAREcpFunc(cpContigTiles2SeparateStrips)
{
    return cpImage(in, out,
                                 readContigTilesIntoBuffer,
                                 writeBufferToSeparateStrips,
                                 imagelength, imagewidth, spp);
}

DECLAREcpFunc(cpSeparateTiles2ContigStrips)
{
    return cpImage(in, out,
                                 readSeparateTilesIntoBuffer,
                                 writeBufferToContigStrips,
                                 imagelength, imagewidth, spp);
}

DECLAREcpFunc(cpSeparateTiles2SeparateStrips)
{
    return cpImage(in, out,
                                 readSeparateTilesIntoBuffer,
                                 writeBufferToSeparateStrips,
                                 imagelength, imagewidth, spp);
}

DECLAREcpFunc(cpContig2ContigByRow)
{
    tsize_t scanlinesize = TIFFScanlineSize(in);
    tdata_t buf;
    uint32 row;
    
    //params
    int ignore = FALSE;
    
    buf = _TIFFmalloc(scanlinesize);
    if (!buf)
        return 0;
    _TIFFmemset(buf, 0, scanlinesize);
    (void) imagewidth; (void) spp;
    for (row = 0; row < imagelength; row++) {
        if (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore) {
            TIFFError(TIFFFileName(in),
                                "Error, can't read scanline %lu",
                                (unsigned long) row);
            goto bad;
        }
        if (TIFFWriteScanline(out, buf, row, 0) < 0) {
            TIFFError(TIFFFileName(out),
                                "Error, can't write scanline %lu",
                                (unsigned long) row);
            goto bad;
        }
    }
    _TIFFfree(buf);
    return 1;
bad:
    _TIFFfree(buf);
    return 0;
}

typedef void biasFn (void *image, void *bias, uint32 pixels);

void subtract8(void *i, void *b, uint32 pixels)
{
    uint8 *image = (uint8 *)i;
    uint8 *bias = (uint8 *)b;
    while (pixels--) {
        *image = *image > *bias ? *image-*bias : 0;
        image++, bias++;
    }
}

void subtract16(void *i, void *b, uint32 pixels)
{
    uint16 *image = (uint16 *)i;
    uint16 *bias = (uint16 *)b;
    while (pixels--) {
        *image = *image > *bias ? *image-*bias : 0;
        image++, bias++;
    }
}

void subtract32(void *i, void *b, uint32 pixels)
{
    uint32 *image = (uint32 *)i;
    uint32 *bias = (uint32 *)b;
    while (pixels--) {
        *image = *image > *bias ? *image-*bias : 0;
        image++, bias++;
    }
}

biasFn *lineSubtractFn (unsigned bits)
{
    switch (bits) {
        case  8:  return subtract8;
        case 16:  return subtract16;
        case 32:  return subtract32;
    }
    return NULL;
}

DECLAREcpFunc(cpBiasedContig2Contig)
{
    //params
    TIFF* bias = NULL;
    int ignore = FALSE;
    
    if (spp == 1) {
        tsize_t biasSize = TIFFScanlineSize(bias);
        tsize_t bufSize = TIFFScanlineSize(in);
        tdata_t buf, biasBuf;
        uint32 biasWidth = 0, biasLength = 0;
        TIFFGetField(bias, TIFFTAG_IMAGEWIDTH, &biasWidth);
        TIFFGetField(bias, TIFFTAG_IMAGELENGTH, &biasLength);
        if (biasSize == bufSize &&
                imagelength == biasLength && imagewidth == biasWidth) {
            uint16 sampleBits = 0;
            biasFn *subtractLine;
            TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &sampleBits);
            subtractLine = lineSubtractFn (sampleBits);
            if (subtractLine) {
                uint32 row;
                buf = _TIFFmalloc(bufSize);
                biasBuf = _TIFFmalloc(bufSize);
                for (row = 0; row < imagelength; row++) {
                    if (TIFFReadScanline(in, buf, row, 0) < 0
                            && !ignore) {
                        TIFFError(TIFFFileName(in),
                                            "Error, can't read scanline %lu",
                                            (unsigned long) row);
                        goto bad;
                    }
                    if (TIFFReadScanline(bias, biasBuf, row, 0) < 0
                            && !ignore) {
                        TIFFError(TIFFFileName(in),
                                            "Error, can't read biased scanline %lu",
                                            (unsigned long) row);
                        goto bad;
                    }
                    subtractLine (buf, biasBuf, imagewidth);
                    if (TIFFWriteScanline(out, buf, row, 0) < 0) {
                        TIFFError(TIFFFileName(out),
                                            "Error, can't write scanline %lu",
                                            (unsigned long) row);
                        goto bad;
                    }
                }
                
                _TIFFfree(buf);
                _TIFFfree(biasBuf);
                TIFFSetDirectory(bias,
                                                 TIFFCurrentDirectory(bias)); /* rewind */
                return 1;
            bad:
                _TIFFfree(buf);
                _TIFFfree(biasBuf);
                return 0;
            } else {
                TIFFError(TIFFFileName(in),
                                    "No support for biasing %d bit pixels\n",
                                    sampleBits);
                return 0;
            }
        }
        TIFFError(TIFFFileName(in),
                            "Bias image %s,%d\nis not the same size as %s,%d\n",
                            TIFFFileName(bias), TIFFCurrentDirectory(bias),
                            TIFFFileName(in), TIFFCurrentDirectory(in));
        return 0;
    } else {
        TIFFError(TIFFFileName(in),
                            "Can't bias %s,%d as it has >1 Sample/Pixel\n",
                            TIFFFileName(in), TIFFCurrentDirectory(in));
        return 0;
    }
    
}

DECLAREcpFunc(cpDecodedStrips)
{
    tsize_t stripsize  = TIFFStripSize(in);
    tdata_t buf = _TIFFmalloc(stripsize);
    
    //params
    uint32 rowsperstrip = (uint32) 0;
    int ignore = FALSE;
    
    (void) imagewidth; (void) spp;
    if (buf) {
        tstrip_t s, ns = TIFFNumberOfStrips(in);
        uint32 row = 0;
        _TIFFmemset(buf, 0, stripsize);
        for (s = 0; s < ns && row < imagelength; s++) {
            tsize_t cc = (row + rowsperstrip > imagelength) ?
            TIFFVStripSize(in, imagelength - row) : stripsize;
            if (TIFFReadEncodedStrip(in, s, buf, cc) < 0
                    && !ignore) {
                TIFFError(TIFFFileName(in),
                                    "Error, can't read strip %lu",
                                    (unsigned long) s);
                goto bad;
            }
            if (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {
                TIFFError(TIFFFileName(out),
                                    "Error, can't write strip %lu",
                                    (unsigned long) s);
                goto bad;
            }
            row += rowsperstrip;
        }
        _TIFFfree(buf);
        return 1;
    } else {
        TIFFError(TIFFFileName(in),
                            "Error, can't allocate memory buffer of size %lu "
                            "to read strips", (unsigned long) stripsize);
        return 0;
    }
    
bad:
    _TIFFfree(buf);
    return 0;
}

DECLAREcpFunc(cpContig2SeparateByRow)
{
    tsize_t scanlinesizein = TIFFScanlineSize(in);
    tsize_t scanlinesizeout = TIFFScanlineSize(out);
    tdata_t inbuf;
    tdata_t outbuf;
    register uint8 *inp, *outp;
    register uint32 n;
    uint32 row;
    tsample_t s;
    uint16 bps = 0;
    
    //params
    int ignore = FALSE;
    
    (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
    if( bps != 8 )
    {
        TIFFError(TIFFFileName(in),
                            "Error, can only handle BitsPerSample=8 in %s",
                            "cpContig2SeparateByRow");
        return 0;
    }
    
    inbuf = _TIFFmalloc(scanlinesizein);
    outbuf = _TIFFmalloc(scanlinesizeout);
    if (!inbuf || !outbuf)
        goto bad;
    _TIFFmemset(inbuf, 0, scanlinesizein);
    _TIFFmemset(outbuf, 0, scanlinesizeout);
    /* unpack channels */
    for (s = 0; s < spp; s++) {
        for (row = 0; row < imagelength; row++) {
            if (TIFFReadScanline(in, inbuf, row, 0) < 0
                    && !ignore) {
                TIFFError(TIFFFileName(in),
                                    "Error, can't read scanline %lu",
                                    (unsigned long) row);
                goto bad;
            }
            inp = ((uint8*)inbuf) + s;
            outp = (uint8*)outbuf;
            for (n = imagewidth; n-- > 0;) {
                *outp++ = *inp;
                inp += spp;
            }
            if (TIFFWriteScanline(out, outbuf, row, s) < 0) {
                TIFFError(TIFFFileName(out),
                                    "Error, can't write scanline %lu",
                                    (unsigned long) row);
                goto bad;
            }
        }
    }
    if (inbuf) _TIFFfree(inbuf);
    if (outbuf) _TIFFfree(outbuf);
    return 1;
bad:
    if (inbuf) _TIFFfree(inbuf);
    if (outbuf) _TIFFfree(outbuf);
    return 0;
}

DECLAREcpFunc(cpSeparate2ContigByRow)
{
    tsize_t scanlinesizein = TIFFScanlineSize(in);
    tsize_t scanlinesizeout = TIFFScanlineSize(out);
    tdata_t inbuf;
    tdata_t outbuf;
    register uint8 *inp, *outp;
    register uint32 n;
    uint32 row;
    tsample_t s;
    uint16 bps = 0;
    
    //params
    int ignore = FALSE;
    
    (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
    if( bps != 8 )
    {
        TIFFError(TIFFFileName(in),
                            "Error, can only handle BitsPerSample=8 in %s",
                            "cpSeparate2ContigByRow");
        return 0;
    }
    
    inbuf = _TIFFmalloc(scanlinesizein);
    outbuf = _TIFFmalloc(scanlinesizeout);
    if (!inbuf || !outbuf)
        goto bad;
    _TIFFmemset(inbuf, 0, scanlinesizein);
    _TIFFmemset(outbuf, 0, scanlinesizeout);
    for (row = 0; row < imagelength; row++) {
        /* merge channels */
        for (s = 0; s < spp; s++) {
            if (TIFFReadScanline(in, inbuf, row, s) < 0
                    && !ignore) {
                TIFFError(TIFFFileName(in),
                                    "Error, can't read scanline %lu",
                                    (unsigned long) row);
                goto bad;
            }
            inp = (uint8*)inbuf;
            outp = ((uint8*)outbuf) + s;
            for (n = imagewidth; n-- > 0;) {
                *outp = *inp++;
                outp += spp;
            }
        }
        if (TIFFWriteScanline(out, outbuf, row, 0) < 0) {
            TIFFError(TIFFFileName(out),
                                "Error, can't write scanline %lu",
                                (unsigned long) row);
            goto bad;
        }
    }
    if (inbuf) _TIFFfree(inbuf);
    if (outbuf) _TIFFfree(outbuf);
    return 1;
bad:
    if (inbuf) _TIFFfree(inbuf);
    if (outbuf) _TIFFfree(outbuf);
    return 0;
}

DECLAREcpFunc(cpSeparate2SeparateByRow)
{
    tsize_t scanlinesize = TIFFScanlineSize(in);
    tdata_t buf;
    uint32 row;
    tsample_t s;
    
    //params
    int ignore = FALSE;
    
    (void) imagewidth;
    buf = _TIFFmalloc(scanlinesize);
    if (!buf)
        return 0;
    _TIFFmemset(buf, 0, scanlinesize);
    for (s = 0; s < spp; s++) {
        for (row = 0; row < imagelength; row++) {
            if (TIFFReadScanline(in, buf, row, s) < 0 && !ignore) {
                TIFFError(TIFFFileName(in),
                                    "Error, can't read scanline %lu",
                                    (unsigned long) row);
                goto bad;
            }
            if (TIFFWriteScanline(out, buf, row, s) < 0) {
                TIFFError(TIFFFileName(out),
                                    "Error, can't write scanline %lu",
                                    (unsigned long) row);
                goto bad;
            }
        }
    }
    _TIFFfree(buf);
    return 1;
bad:
    _TIFFfree(buf);
    return 0;
}

copyFunc
pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel,
                         //params
                         uint32 tilewidth,
                         uint32 tilelength,
                         uint32 rowsperstrip,
                         uint16 config,
                         TIFF* bias)
{
    uint16 shortv;
    uint32 w, l, tw, tl;
    int bychunk;
    
    (void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);
    if (shortv != config && bitspersample != 8 && samplesperpixel > 1) {
        fprintf(stderr,
            "%s: Cannot handle different planar configuration w/ bits/sample != 8\n",
            TIFFFileName(in));
        return (NULL);
    }
    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);
    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);
    if (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {
        uint32 irps = (uint32) -1L;
        TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);
        /* if biased, force decoded copying to allow image subtraction */
        bychunk = !bias && (rowsperstrip == irps);
    }else{  /* either in or out is tiled */
        if (bias) {
            fprintf(stderr,
                "%s: Cannot handle tiled configuration w/bias image\n",
                            TIFFFileName(in));
            return (NULL);
        }
        if (TIFFIsTiled(out)) {
            if (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw))
                tw = w;
            if (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl))
                tl = l;
            bychunk = (tw == tilewidth && tl == tilelength);
        } else {  /* out's not, so in must be tiled */
            TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
            TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);
            bychunk = (tw == w && tl == rowsperstrip);
        }
    }
#define    T 1
#define    F 0
#define pack(a,b,c,d,e)    ((long)(((a)<<11)|((b)<<3)|((c)<<2)|((d)<<1)|(e)))
    switch(pack(shortv,config,TIFFIsTiled(in),TIFFIsTiled(out),bychunk)) {
            /* Strips -> Tiles */
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,F):
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,T):
            return cpContigStrips2ContigTiles;
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,F):
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,T):
            return cpContigStrips2SeparateTiles;
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,F):
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,T):
            return cpSeparateStrips2ContigTiles;
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,F):
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,T):
            return cpSeparateStrips2SeparateTiles;
            /* Tiles -> Tiles */
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,F):
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,T):
            return cpContigTiles2ContigTiles;
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,F):
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,T):
            return cpContigTiles2SeparateTiles;
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,F):
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,T):
            return cpSeparateTiles2ContigTiles;
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,F):
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,T):
            return cpSeparateTiles2SeparateTiles;
            /* Tiles -> Strips */
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,F):
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,T):
            return cpContigTiles2ContigStrips;
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,F):
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,T):
            return cpContigTiles2SeparateStrips;
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,F):
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,T):
            return cpSeparateTiles2ContigStrips;
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,F):
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,T):
            return cpSeparateTiles2SeparateStrips;
            /* Strips -> Strips */
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,F):
            return bias ? cpBiasedContig2Contig : cpContig2ContigByRow;
        case pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,T):
            return cpDecodedStrips;
        case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,F):
        case pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,T):
            return cpContig2SeparateByRow;
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,F):
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,T):
            return cpSeparate2ContigByRow;
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,F):
        case pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,T):
            return cpSeparate2SeparateByRow;
    }
#undef pack
#undef F
#undef T
    fprintf(stderr, "tiffcp: %s: Don't know how to copy/convert image.\n",
        TIFFFileName(in));
    return (NULL);
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Image DPI
            
			case 1 :
				Set_image_DPI(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void ob_set_s(PA_ObjectRef obj, const wchar_t *_key, PA_Unistring *_value) {
    
    CUTF16String value = CUTF16String(_value->fString, _value->fLength);
        
    ob_set_a(obj, _key, &value);
}

bool is_image_format(PA_Unistring *type, const char *format) {
    
    C_TEXT t;
    t.setUTF16String(type);
    CUTF8String _type;
    t.copyUTF8String(&_type);
    
    size_t pos = 0, found = 0;
    for(pos = _type.find(';'); pos != CUTF8String::npos; pos = _type.find(';', found)) {
        CUTF8String typestring = _type.substr(found, pos-found);
        if(typestring == (const uint8_t *)format) {
            return true;
        }
        found = pos + 1;
    }
    return false;
}

uint16 get_page_count(TIFF *tiff) {
    
    uint16 count = 0;
    
    do
    {
        count++;
    } while (TIFFReadDirectory(tiff));
    
    return count;
}

int tiffcpy(TIFF* in, TIFF* out, float dpi) {
    
    uint16 bitspersample = 1, samplesperpixel = 1;
    uint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;
    copyFunc cf;
    uint32 width, length;
    struct cpTag* p;
    
    //params
    uint16 compression = (uint16) -1;//default
    int jpegcolormode = JPEGCOLORMODE_RGB;
    uint16 fillorder = 0;
    uint16 orientation;
    int outtiled = -1;
    uint32 tilewidth = (uint32) -1;
    uint32 tilelength = (uint32) -1;
    uint32 rowsperstrip = (uint32) 0;
    uint16 config = (uint16) -1;
    int quality = 75;
    uint16 predictor = (uint16) -1;
    int preset = -1;
    uint32 g3opts = (uint32) -1;
    int pageInSeq = 0;
    int pageNum = 0;
    
    CopyField(TIFFTAG_IMAGEWIDTH, width);
    CopyField(TIFFTAG_IMAGELENGTH, length);
    CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);
    CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);
        
    if (compression != (uint16)-1)
        TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
    else
        CopyField(TIFFTAG_COMPRESSION, compression);
    TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);
    TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);
    if (input_compression == COMPRESSION_JPEG) {
        /* Force conversion to RGB */
        TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
    } else if (input_photometric == PHOTOMETRIC_YCBCR) {
        /* Otherwise, can't handle subsampled input */
        uint16 subsamplinghor,subsamplingver;
        
        TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
                                                    &subsamplinghor, &subsamplingver);
        if (subsamplinghor!=1 || subsamplingver!=1) {
            fprintf(stderr, "tiffcp: %s: Can't copy/convert subsampled image.\n",
                            TIFFFileName(in));
            return FALSE;
        }
    }
    if (compression == COMPRESSION_JPEG) {
        if (input_photometric == PHOTOMETRIC_RGB &&
                jpegcolormode == JPEGCOLORMODE_RGB)
            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
        else
            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
    }
    else if (compression == COMPRESSION_SGILOG
                     || compression == COMPRESSION_SGILOG24)
        TIFFSetField(out, TIFFTAG_PHOTOMETRIC,
                                 samplesperpixel == 1 ?
                                 PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
    else if (input_compression == COMPRESSION_JPEG &&
                     samplesperpixel == 3 ) {
        /* RGB conversion was forced above
         hence the output will be of the same type */
        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
    }
    else
        CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);
    if (fillorder != 0)
        TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);
    else
        CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);
    /*
     * Will copy `Orientation' tag from input image
     */
    TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
    switch (orientation) {
        case ORIENTATION_BOTRIGHT:
        case ORIENTATION_RIGHTBOT:    /* XXX */
            TIFFWarning(TIFFFileName(in), "using bottom-left orientation");
            orientation = ORIENTATION_BOTLEFT;
            /* fall thru... */
        case ORIENTATION_LEFTBOT:    /* XXX */
        case ORIENTATION_BOTLEFT:
            break;
        case ORIENTATION_TOPRIGHT:
        case ORIENTATION_RIGHTTOP:    /* XXX */
        default:
            TIFFWarning(TIFFFileName(in), "using top-left orientation");
            orientation = ORIENTATION_TOPLEFT;
            /* fall thru... */
        case ORIENTATION_LEFTTOP:    /* XXX */
        case ORIENTATION_TOPLEFT:
            break;
    }
    TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);
    /*
     * Choose tiles/strip for the output image according to
     * the command line arguments (-tiles, -strips) and the
     * structure of the input image.
     */
    if (outtiled == -1)
        outtiled = TIFFIsTiled(in);
    if (outtiled) {
        /*
         * Setup output file's tile width&height.  If either
         * is not specified, use either the value from the
         * input image or, if nothing is defined, use the
         * library default.
         */
        if (tilewidth == (uint32) -1)
            TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);
        if (tilelength == (uint32) -1)
            TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);
        TIFFDefaultTileSize(out, &tilewidth, &tilelength);
        TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);
        TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);
    } else {
        /*
         * RowsPerStrip is left unspecified: use either the
         * value from the input image or, if nothing is defined,
         * use the library default.
         */
        if (rowsperstrip == (uint32) 0) {
            if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,
                                                &rowsperstrip)) {
                rowsperstrip =
                TIFFDefaultStripSize(out, rowsperstrip);
            }
            if (rowsperstrip > length && rowsperstrip != (uint32)-1)
                rowsperstrip = length;
        }
        else if (rowsperstrip == (uint32) -1)
            rowsperstrip = length;
        TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
    }
    if (config != (uint16) -1)
        TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
    else
        CopyField(TIFFTAG_PLANARCONFIG, config);
    if (samplesperpixel <= 4)
        CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
    CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);
    /* SMinSampleValue & SMaxSampleValue */
    switch (compression) {
        case COMPRESSION_JPEG:
            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
            TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);
            break;
        case COMPRESSION_JBIG:
            CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
            CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
            CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
            CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);
            break;
        case COMPRESSION_LZW:
        case COMPRESSION_ADOBE_DEFLATE:
        case COMPRESSION_DEFLATE:
        case COMPRESSION_LZMA:
            if (predictor != (uint16)-1)
                TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
            else
                CopyField(TIFFTAG_PREDICTOR, predictor);
            if (preset != -1) {
                if (compression == COMPRESSION_ADOBE_DEFLATE
                        || compression == COMPRESSION_DEFLATE)
                    TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);
                else if (compression == COMPRESSION_LZMA)
                    TIFFSetField(out, TIFFTAG_LZMAPRESET, preset);
            }
            break;
        case COMPRESSION_CCITTFAX3:
        case COMPRESSION_CCITTFAX4:
            if (compression == COMPRESSION_CCITTFAX3) {
                if (g3opts != (uint32) -1)
                    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS,
                                             g3opts);
                else
                    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);
            } else
                CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
            CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
            CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
            CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
            CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
            CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
            CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
            break;
    }
    {
        uint32 len32;
        void** data;
        if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))
            TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);
    }
    {
        uint16 ninks;
        const char* inknames;
        if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {
            TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
            if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {
                size_t inknameslen = strlen(inknames) + 1;
                const char* cp = inknames;
                while (ninks > 1) {
                    cp = strchr(cp, '\0');
                    cp++;
                    inknameslen += (strlen(cp) + 1);
                    ninks--;
                }
                TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);
            }
        }
    }
    {
        unsigned short pg0, pg1;
        
        if (pageInSeq == 1) {
            if (pageNum < 0) /* only one input file */ {
                if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))
                    TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
            } else
                TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
            
        } else {
            if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {
                if (pageNum < 0) /* only one input file */
                    TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
                else
                    TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
            }
        }
    }
    
    for (p = tags; p < &tags[NTAGS]; p++)
        CopyTag(p->tag, p->count, p->type);
    
    TIFF* bias = NULL;
    
    cf = pickCopyFunc(in, out, bitspersample, samplesperpixel,
                                        tilewidth,
                                        tilelength,
                                        rowsperstrip,
                                        config,
                                        bias);
    
    if(dpi > 0) {
        TIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);
        TIFFSetField(out, TIFFTAG_XRESOLUTION, (float)dpi);//important to use float
        TIFFSetField(out, TIFFTAG_YRESOLUTION, (float)dpi);//important to use float
    }
    
    return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);
}

#pragma mark PNG

typedef struct {
    
    unsigned char *ptr;
    PA_long32 pos;
    PA_long32 len;
    
}pa_handle_t;

void read_data_fn(png_structp png_ptr, png_bytep buf, png_size_t size)
{
    pa_handle_t *pa_handle = (pa_handle_t *)png_get_io_ptr(png_ptr);
    
    size_t pos = pa_handle->pos;
    
    if((pos + size) <= pa_handle->len){
        memcpy(buf, (const void *)&pa_handle->ptr[pos], size);
        pa_handle->pos += size;
    }
}


void write_data_fn(png_structp png_ptr, png_bytep buf, png_size_t size)
{
    C_BLOB *blob = (C_BLOB *)png_get_io_ptr(png_ptr);
    blob->addBytes((const uint8_t *)buf, (uint32_t)size);
}

void output_flush_fn(png_structp png_ptr)
{
    
}

struct my_error_mgr
{
    struct jpeg_error_mgr pub;
    jmp_buf setjmp_buffer;
    int     jump_set;
};

typedef struct my_error_mgr * my_error_ptr;

typedef struct {
    struct jpeg_destination_mgr pub; /* public fields */
    
    unsigned char **buf_ptr;
    size_t *bufsize_ptr;
    size_t incsize;
    
    unsigned char *buf;
    size_t bufsize;
    
} jpeg_memory_destination_mgr;

void my_error_exit (j_common_ptr cinfo)
{

}

void my_output_message (j_common_ptr cinfo)
{

}

typedef jpeg_memory_destination_mgr* jpeg_memory_destination_ptr;

void jpeg_memory_init_destination (j_compress_ptr cinfo)
{
    jpeg_memory_destination_ptr dest = (jpeg_memory_destination_ptr) cinfo->dest;
    dest->pub.next_output_byte = dest->buf;
    dest->pub.free_in_buffer = dest->bufsize;
}

#if VERSIONWIN
#define _false FALSE
#define _true TRUE
#endif

boolean jpeg_memory_empty_output_buffer (j_compress_ptr cinfo)
{
    jpeg_memory_destination_ptr dest = (jpeg_memory_destination_ptr) cinfo->dest;
    unsigned char *newbuf;
    /* abort if incsize is 0 (no expansion of buffer allowed) */
    if (dest->incsize == 0) return _false;
    /* otherwise, try expanding buffer... */
    newbuf = (unsigned char *)realloc(dest->buf,dest->bufsize + dest->incsize);
    if (!newbuf) return _false;
    dest->pub.next_output_byte = newbuf + dest->bufsize;
    dest->pub.free_in_buffer = dest->incsize;
    dest->buf = newbuf;
    dest->bufsize += dest->incsize;
    dest->incsize *= 2;
    return _true;
}

void jpeg_memory_term_destination (j_compress_ptr cinfo)
{
    jpeg_memory_destination_ptr dest = (jpeg_memory_destination_ptr) cinfo->dest;
    *dest->buf_ptr = dest->buf;
    *dest->bufsize_ptr = dest->bufsize - dest->pub.free_in_buffer;
}

void jpeg_memory_dest (j_compress_ptr cinfo, unsigned char **bufptr, size_t *bufsizeptr, size_t incsize)
{
    jpeg_memory_destination_ptr dest;
    
    /* allocate destination manager object for compress object, if needed */
    if (!cinfo->dest) {
        cinfo->dest = (struct jpeg_destination_mgr *)
        (*cinfo->mem->alloc_small) ( (j_common_ptr) cinfo,
                                                                JPOOL_PERMANENT,
                                                                sizeof(jpeg_memory_destination_mgr) );
    }
    
    dest = (jpeg_memory_destination_ptr)cinfo->dest;
    
    dest->buf_ptr = bufptr;
    dest->buf = *bufptr;
    dest->bufsize_ptr = bufsizeptr;
    dest->bufsize = *bufsizeptr;
    dest->incsize = incsize;
    
    dest->pub.init_destination = jpeg_memory_init_destination;
    dest->pub.empty_output_buffer = jpeg_memory_empty_output_buffer;
    dest->pub.term_destination = jpeg_memory_term_destination;
}

#define JPEG_STRIP_XMP 1
#define JPEG_STRIP_ICC 2
#define JPEG_STRIP_IPTC 4
#define JPEG_STRIP_EXIF 8
#define JPEG_STRIP_COM 16

#define EXIF_JPEG_MARKER   JPEG_APP0+1
#define EXIF_IDENT_STRING  "Exif\000\000"
#define EXIF_IDENT_STRING_SIZE 6

#define IPTC_JPEG_MARKER   JPEG_APP0+13

#define ICC_JPEG_MARKER   JPEG_APP0+2
#define ICC_IDENT_STRING  "ICC_PROFILE\0"
#define ICC_IDENT_STRING_SIZE 12

#define XMP_JPEG_MARKER   JPEG_APP0+1
#define XMP_IDENT_STRING  "http://ns.adobe.com/xap/1.0/\000"
#define XMP_IDENT_STRING_SIZE 29

void write_dpi(struct jpeg_decompress_struct *dinfo,
                   struct jpeg_compress_struct *cinfo,
                   float dpi) {
    
    jpeg_saved_marker_ptr mrk;

    mrk=dinfo->marker_list;
    while (mrk)
    {
        /* JFIF (APP0) marker */
        if ( mrk->marker == JPEG_APP0 && mrk->data_length >= 14 &&
            mrk->data[0] == 0x4a &&
            mrk->data[1] == 0x46 &&
            mrk->data[2] == 0x49 &&
            mrk->data[3] == 0x46 &&
            mrk->data[4] == 0x00 ) {
            
            /* JFIF_major_version */
            /* JFIF_minor_version */
            
            mrk->data[ 7]  = 0x01;/*  density_unit */
            
            UINT16 X_density = (UINT16)dpi;
            UINT16 Y_density = (UINT16)dpi;
            
            memcpy(&mrk->data[ 8], &X_density, sizeof(X_density));
            memcpy(&mrk->data[10], &Y_density, sizeof(Y_density));
            
            jpeg_write_marker(cinfo,mrk->marker,mrk->data,mrk->data_length);
            
            break;
        }

        
        mrk=mrk->next;
    }
}


void write_markers(struct jpeg_decompress_struct *dinfo,
                   struct jpeg_compress_struct *cinfo,
                   float dpi) {
    
    jpeg_saved_marker_ptr mrk;
    
    int write_marker;

    mrk=dinfo->marker_list;
    while (mrk)
    {
        write_marker=0;
        
        /* check for markers to save... */
        
        if (mrk->marker == JPEG_COM)
            write_marker++;
        
        if (mrk->marker == IPTC_JPEG_MARKER)
            write_marker++;
        
        if (mrk->marker == EXIF_JPEG_MARKER &&
                !memcmp(mrk->data,EXIF_IDENT_STRING,EXIF_IDENT_STRING_SIZE))
            write_marker++;
        
        if (mrk->marker == ICC_JPEG_MARKER &&
                !memcmp(mrk->data,ICC_IDENT_STRING,ICC_IDENT_STRING_SIZE))
            write_marker++;
        
        if (mrk->marker == XMP_JPEG_MARKER &&
                !memcmp(mrk->data,XMP_IDENT_STRING,XMP_IDENT_STRING_SIZE))
            write_marker++;
        
        /* libjpeg emits some markers automatically so skip these to avoid duplicates... */
        
        if ( mrk->marker == JPEG_APP0 && mrk->data_length >= 14 &&
            mrk->data[0] == 0x4a &&
            mrk->data[1] == 0x46 &&
            mrk->data[2] == 0x49 &&
            mrk->data[3] == 0x46 &&
            mrk->data[4] == 0x00 ) {
            
            mrk->data[7]  = 0x01; /*  density_unit */
            
            UINT16 X_density = (UINT16)dpi;
            UINT16 Y_density = (UINT16)dpi;
            
            memcpy(&mrk->data[ 8], &X_density, sizeof(X_density));
            memcpy(&mrk->data[10], &Y_density, sizeof(Y_density));
            
            write_marker++;
        }

        if ( mrk->marker == JPEG_APP0+14 && mrk->data_length >= 12 &&
                mrk->data[0] == 0x41 &&
                mrk->data[1] == 0x64 &&
                mrk->data[2] == 0x6f &&
                mrk->data[3] == 0x62 &&
            mrk->data[4] == 0x65 ) {
            
            write_marker++;
        }
            
        if (write_marker)
            jpeg_write_marker(cinfo,mrk->marker,mrk->data,mrk->data_length);
        
        mrk=mrk->next;
    }
}

#define FREE_LINE_BUF(buf,lines)  {                \
  int j;                            \
  for (j=0;j<lines;j++) free(buf[j]);                \
  free(buf);                            \
  buf=NULL;                            \
}

void Set_image_DPI(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    PA_Picture image = PA_GetPictureParameter(params, 1);
    float dpi = (float)PA_GetLongParameter(params, 2);
    
    ob_set_b(returnValue, L"success", false);
    PA_CollectionRef formats = PA_CreateCollection();
    
    if(image) {
        
        PA_long32 i = 0;
        PA_ErrorCode err = eER_NoErr;
        
        while (err == eER_NoErr) {
            
            PA_Unistring type = PA_GetPictureData(image, ++i, NULL);
            err = PA_GetLastError();
            if(err == eER_NoErr) {
                
                PA_Handle h = PA_NewHandle(0);
                PA_GetPictureData(image, i, h);
                if(PA_GetLastError() == eER_NoErr) {
                    
                    PA_ObjectRef format = PA_CreateObject();
                    ob_set_s(format, L"type", &type);
                    
                    void *ptr = (void *)PA_LockHandle(h);
                    PA_long32 len = PA_GetHandleSize(h);
                    
                    if(is_image_format(&type, "image/jpeg")) {
                        
                        struct jpeg_decompress_struct dinfo;
                        struct jpeg_compress_struct cinfo;
                        struct my_error_mgr jcerr, jderr;
                        
                        jvirt_barray_ptr *coef_arrays = NULL;
                        JSAMPARRAY buf = NULL;
                                                
                        /* initialize decompression object */
                        dinfo.err = jpeg_std_error(&jderr.pub);
                        jpeg_create_decompress(&dinfo);
                        jderr.pub.error_exit=my_error_exit;
                        jderr.pub.output_message=my_output_message;
                        jderr.jump_set = 0;
                        
                        /* initialize compression object */
                        cinfo.err = jpeg_std_error(&jcerr.pub);
                        jpeg_create_compress(&cinfo);
                        jcerr.pub.error_exit=my_error_exit;
                        jcerr.pub.output_message=my_output_message;
                        jcerr.jump_set = 0;
                        
                        if (setjmp(jderr.setjmp_buffer))
                        {
                            /* error handler for decompress */
                            jpeg_abort_decompress(&dinfo);

                            jderr.jump_set=0;
                        } else {
                            jderr.jump_set=1;
                        }
                        
                        /* prepare to decompress */
                        jpeg_save_markers(&dinfo, JPEG_COM, 0xffff);
                        for (int j=0;j<=15;j++)
                            jpeg_save_markers(&dinfo, JPEG_APP0+j, 0xffff);
                        jpeg_mem_src(&dinfo, (unsigned char *)ptr, len);
                        jpeg_read_header(&dinfo, _true);
                        
                        jpeg_start_decompress(&dinfo);
                        
                        coef_arrays = jpeg_read_coefficients(&dinfo);
                        
                        if(!coef_arrays) {
                            
                            buf = (JSAMPARRAY)malloc(sizeof(JSAMPROW)*dinfo.output_height);
                            for (int j=0;j<dinfo.output_height;j++) {
                                buf[j]=(JSAMPROW)malloc(sizeof(JSAMPLE)*dinfo.output_width*dinfo.out_color_components);
                            }
                            while (dinfo.output_scanline < dinfo.output_height) {
                                jpeg_read_scanlines(&dinfo,&buf[dinfo.output_scanline], dinfo.output_height-dinfo.output_scanline);
                            }
                        }
                        
                        if (setjmp(jcerr.setjmp_buffer))
                        {
                            /* error handler for compress failures */
                            jpeg_abort_compress(&cinfo);
                            jpeg_abort_decompress(&dinfo);
                            
                            jcerr.jump_set=0;
                        } else {
                            jcerr.jump_set=1;
                        }
                        
                        size_t outbuffersize = len + 32768;
                        unsigned char *outbuffer = (unsigned char *)malloc(outbuffersize);
                        
                        if(outbuffer) {
                            
                            jpeg_memory_dest(&cinfo, &outbuffer, &outbuffersize, 65536);
                            
                            if(coef_arrays) {
                                jpeg_copy_critical_parameters(&dinfo, &cinfo);
                                jpeg_simple_progression(&cinfo);
                                cinfo.optimize_coding = _true;
                            }else{
                                cinfo.in_color_space=dinfo.out_color_space;
                                cinfo.input_components=dinfo.output_components;
                                cinfo.image_width=dinfo.image_width;
                                cinfo.image_height=dinfo.image_height;
                                jpeg_set_defaults(&cinfo);
                                jpeg_set_quality(&cinfo, 100, _true);
                                jpeg_simple_progression(&cinfo);
                                cinfo.optimize_coding = _true;
                                jpeg_start_compress(&cinfo,_true);
                            }

                            write_markers(&dinfo,&cinfo, dpi);
                            
                            if(coef_arrays) {
                                jpeg_write_coefficients(&cinfo, coef_arrays);
                            }else{
                                while (cinfo.next_scanline < cinfo.image_height)
                                {
                                    jpeg_write_scanlines(&cinfo,&buf[cinfo.next_scanline], dinfo.output_height);
                                }
                            }
                            
                            jpeg_finish_decompress(&dinfo);
                            
                            if(!coef_arrays) {
                                
                                jpeg_finish_compress(&cinfo);
                                FREE_LINE_BUF(buf,dinfo.output_height);
                                
                            }
                            
                            jpeg_destroy_decompress(&dinfo);
                            jpeg_destroy_compress(&cinfo);
                            
                            PA_Picture p = PA_CreatePicture((void *)outbuffer, (PA_long32)outbuffersize);
                            
                            ob_set_p(format, L"image", p);
                            ob_set_b(returnValue, L"success", true);
                            
                            free(outbuffer);
                        }
                    }
                        
                    if(is_image_format(&type, "image/png")) {
                        
                        png_structp png_ptr_in = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
                        if (png_ptr_in) {
                            png_infop info_ptr_in = png_create_info_struct(png_ptr_in);
                            if (!info_ptr_in) {
                                png_destroy_read_struct(&png_ptr_in, NULL, NULL);
                            }else {
                                if (setjmp(png_jmpbuf(png_ptr_in)) != 0) {
                                    // Ok we are here because of the setjmp.
                                    png_destroy_read_struct(&png_ptr_in, &info_ptr_in, NULL);
                                }else {
                                    const unsigned int png_transforms =
                                    PNG_TRANSFORM_PACKING | PNG_TRANSFORM_EXPAND | PNG_TRANSFORM_STRIP_16;
                                    
                                    pa_handle_t pa_handle;
                                    pa_handle.len = len;
                                    pa_handle.ptr = (unsigned char *)ptr;
                                    pa_handle.pos = 0;
                                    
                                    png_set_read_fn(png_ptr_in, (png_voidp)&pa_handle, read_data_fn);
                                    png_read_png(png_ptr_in, info_ptr_in, png_transforms, NULL);
                                    
                                    png_structp png_ptr_out = png_create_write_struct (png_get_libpng_ver(NULL), NULL, NULL, NULL);
                                    
                                    if (png_ptr_out) {
                                        png_infop info_ptr_out = png_create_info_struct (png_ptr_out);
                                        if (!info_ptr_out) {
                                          png_destroy_write_struct (&png_ptr_out, NULL);
                                        }else{
                                            if (setjmp (png_jmpbuf (png_ptr_out))) {
                                              png_destroy_write_struct (&png_ptr_out, &info_ptr_out);
                                            }else{

                                                C_BLOB outPNG;
                                                
                                                png_set_write_fn(png_ptr_out, (png_voidp)&outPNG,
                                                                 write_data_fn, output_flush_fn);
                                                
                                                //----------------[IHDR]
                                                png_uint_32 width, height;
                                                int bit_depth, color_type;
                                                int interlace_method = 0;
                                                int compression_method, filter_method;
                                                if (png_get_IHDR(png_ptr_in, info_ptr_in,
                                                                 &width, &height,
                                                                 &bit_depth, &color_type,
                                                                 &interlace_method,
                                                                 &compression_method, &filter_method)) {
                                                    png_set_IHDR (png_ptr_out, info_ptr_out,
                                                                  width, height, bit_depth, color_type,
                                                                  interlace_method,
                                                                  compression_method,
                                                                  filter_method);
                                                }
                                               
                                                //----------------[bKGD]
                                                png_color_16p background;
                                                if (png_get_bKGD(png_ptr_in, info_ptr_in, &background)) {
                                                    png_set_bKGD(png_ptr_out, info_ptr_out, background);
                                                }
                                                
                                                //----------------[cHRM]
                                                png_fixed_point white_x, white_y, red_x, red_y,
                                                green_x, green_y, blue_x, blue_y;
                                                if (png_get_cHRM_fixed(png_ptr_in, info_ptr_in,
                                                                       &white_x, &white_y,
                                                                       &red_x, &red_y,
                                                                       &green_x, &green_y,
                                                                       &blue_x,&blue_y)) {
                                                    png_set_cHRM_fixed(png_ptr_out, info_ptr_out,
                                                                       white_x, white_y,
                                                                       red_x, red_y,
                                                                       green_x, green_y,
                                                                       blue_x, blue_y);
                                                }

                                                //----------------[gAMA]
                                                png_fixed_point file_gamma;
                                                if (png_get_gAMA_fixed(png_ptr_in, info_ptr_in, &file_gamma)) {
                                                    png_set_gAMA_fixed(png_ptr_out, info_ptr_out, file_gamma);
                                                }
                                                
                                                //----------------[sRGB]
                                                int file_intent;
                                                if (png_get_sRGB(png_ptr_in, info_ptr_in, &file_intent)) {
                                                    png_set_sRGB(png_ptr_out, info_ptr_out, file_intent);
                                                }
                                                
                                                //----------------[iCCP]
                                                png_charp name;
                                                png_bytep profile;
                                                png_uint_32 proflen;
                                                if(png_get_iCCP(png_ptr_in, info_ptr_in,
                                                                                    (png_charpp)&name,
                                                                                    (int *)&compression_method,
                                                                                    (png_bytepp)&profile,
                                                                                    (png_uint_32 *)&proflen)) {
                                                        png_set_iCCP(png_ptr_out, info_ptr_out,
                                                                     (png_const_charp)name,
                                                                     (int)compression_method,
                                                                     (png_const_bytep)profile,
                                                                     (png_uint_32)proflen);
                                                }
                                                
                                                //----------------[oFFs]
                                                png_charp purpose, units;
                                                png_charpp params;
                                                png_int_32 X0, X1;
                                                int type, nparams;
                                                if (png_get_pCAL(png_ptr_in, info_ptr_in,
                                                                 &purpose, &X0, &X1,
                                                                 &type, &nparams, &units, &params)) {
                                                    png_set_pCAL(png_ptr_out, info_ptr_out,
                                                                 purpose, X0, X1,
                                                                 type, nparams,
                                                                 units, params);
                                                }
  
                                                //----------------[pHYs]
                                                png_uint_32 res_x, res_y;
                                                int unit_type;
                                                if (dpi > 0) {
                                                    unit_type = PNG_RESOLUTION_METER;
                                                    res_x = res_y =
                                                    (png_uint_32) ((dpi / .0254 + 0.5));
                                                    png_set_pHYs(png_ptr_out, info_ptr_out, res_x, res_y, unit_type);
                                                }

                                                //----------------[hIST]
                                                png_uint_16p hist;
                                                if (png_get_hIST(png_ptr_in, info_ptr_in, &hist)) {
                                                        png_set_hIST(png_ptr_out, info_ptr_out, hist);
                                                }
                                                
                                                //----------------[tRNS]
                                                png_bytep trans;
                                                int num_trans;
                                                png_color_16p trans_values;
                                                if (png_get_tRNS(png_ptr_in, info_ptr_in,
                                                                 &trans, &num_trans, &trans_values)) {
                                                    png_set_tRNS(png_ptr_out, info_ptr_out, trans, num_trans, trans_values);
                                                }
                                                
                                                //----------------[PLTE]
                                                int num_palette = 0;
                                                png_colorp palette;
                                                if (png_get_PLTE(png_ptr_in, info_ptr_in, &palette, &num_palette)) {
                                                    png_set_PLTE(png_ptr_out, info_ptr_out, palette, num_palette);
                                                }
                                                
                                                //----------------[sBIT]
                                                png_color_8p sig_bit;
                                                if (png_get_sBIT(png_ptr_in, info_ptr_in, &sig_bit)) {
                                                    png_set_sBIT(png_ptr_out, info_ptr_out, sig_bit);
                                                }
                                                
                                                //----------------[sCAL]
                                                int unit;
                                                double scal_width, scal_height;
                                                if (png_get_sCAL(png_ptr_in, info_ptr_in, &unit, &scal_width,
                                                     &scal_height)) {
                                                    png_set_sCAL(png_ptr_out, info_ptr_out, unit, scal_width, scal_height);
                                                }

                                                //----------------[sPLT]
                                                png_sPLT_tp entries;
                                                int num_entries = (int) png_get_sPLT(png_ptr_in, info_ptr_in, &entries);
                                                if (num_entries) {
                                                    png_set_sPLT(png_ptr_out, info_ptr_out, entries, num_entries);
                                                }

                                                //----------------[tEXt/zTXt/iTXt]
                                                png_textp text_ptr;
                                                int num_text = 0;
                                                if (png_get_text(png_ptr_in, info_ptr_in, &text_ptr, &num_text) > 0) {
                                                    png_set_text(png_ptr_out, info_ptr_out, text_ptr, num_text);
                                                }

                                                //----------------[tIME]
                                                png_timep mod_time;
                                                if (png_get_tIME(png_ptr_in, info_ptr_in, &mod_time)) {
                                                    png_set_tIME(png_ptr_out, info_ptr_out, mod_time);
                                                }
                                                
                                                png_write_info (png_ptr_out, info_ptr_out);
                                                
                                                png_bytep* row_pointers = png_get_rows(png_ptr_in, info_ptr_in);
                                                png_write_image (png_ptr_out, row_pointers);
                                                
                                                png_write_end (png_ptr_out, info_ptr_out);
                                                png_destroy_write_struct (&png_ptr_out, &info_ptr_out);
                                                
                                                PA_Picture p = PA_CreatePicture((void *)outPNG.getBytesPtr(), (PA_long32)outPNG.getBytesLength());
                                                
                                                ob_set_p(format, L"image", p);
                                                ob_set_b(returnValue, L"success", true);
                                            }
                                        }
                                    }
                                    png_destroy_read_struct(&png_ptr_in, &info_ptr_in, NULL);
                                }
                            }
                        }
                    }
                            
                    if(is_image_format(&type, "image/bmp")) {
                        
                    }
            
                    if(is_image_format(&type, "image/tiff")) {
                        
                        TIFF *tiff = 0;
                        tiff_src tiff_input;
                        tiff_input.ptr = (uint8_t *)ptr;
                        tiff_input.len = len;
                        tiff_input.pos = 0;
                        
                        if(tiff_input.len) {
                            tiff = TIFFClientOpen(
                                                  "tiff_in",
                                                  "r",
                                                  (thandle_t)&tiff_input,
                                                  tiff_Read,
                                                  tiff_Write,
                                                  tiff_ReadSeek,
                                                  tiff_Close,
                                                  tiff_ReadSize,
                                                  tiff_Map,
                                                  tiff_Unmap);
                            if(tiff) {
                                
                                std::vector<uint8_t> buf(0);
                                tiff_dst tiff_output;
                                tiff_output.pos = 0;
                                tiff_output.buf = &buf;
                                
                                TIFF *result = TIFFClientOpen(
                                                              "tiff_out",
                                                              TIFFIsBigEndian(tiff) ? "wb" : "wl",
                                                              (thandle_t)&tiff_output,
                                                              tiff_WriteRead,
                                                              tiff_Write,
                                                              tiff_WriteSeek,
                                                              tiff_Close,
                                                              tiff_WriteSize,
                                                              tiff_Map,
                                                              tiff_Unmap);
                                     
                                if(result) {
                                    
                                    uint16 src_count_pages = get_page_count(tiff);
                                    for (uint16 dir = 0; dir < src_count_pages;++dir) {
                                        
                                        TIFFSetDirectory(tiff, dir);
                                        tiffcpy(tiff, result, dpi);
                                        TIFFWriteDirectory(result);
                                        
                                    }

                                    TIFFClose(result);
                                    
                                    PA_Picture p = PA_CreatePicture((void *)&buf[0], (PA_long32)buf.size());
                                    
                                    ob_set_p(format, L"image", p);
                                    ob_set_b(returnValue, L"success", true);
                                }
                            }
                            TIFFClose(tiff);
                        }
                    }
                    
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, format);
                    PA_SetCollectionElement(formats, PA_GetCollectionLength(formats), v);
                }
                PA_UnlockHandle(h);
            }
        }
    }

    ob_set_c(returnValue, L"formats", formats);
    
    PA_ReturnObject(params, returnValue);
}
